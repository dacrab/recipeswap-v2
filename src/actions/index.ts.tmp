import { defineAction } from 'astro:actions';
import { z } from 'astro:schema';
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import { db } from '../db';
import { recipes, comments, likes, bookmarks } from '../db/schema';
import { nanoid } from 'nanoid';
import { eq, and } from 'drizzle-orm';

const S3 = new S3Client({
  region: "auto",
  endpoint: `https://${import.meta.env.CLOUDFLARE_ACCOUNT_ID}.r2.cloudflarestorage.com`,
  credentials: {
    accessKeyId: import.meta.env.CLOUDFLARE_ACCESS_KEY_ID,
    secretAccessKey: import.meta.env.CLOUDFLARE_SECRET_ACCESS_KEY,
  },
});

export const server = {
  // ... existing actions (getPresignedUrl, createRecipe, updateRecipe, deleteRecipe)
  getPresignedUrl: server.getPresignedUrl,
  createRecipe: server.createRecipe,
  updateRecipe: server.updateRecipe,
  deleteRecipe: server.deleteRecipe,

  toggleLike: defineAction({
    accept: 'json',
    input: z.object({ recipeId: z.string() }),
    handler: async ({ recipeId }, context) => {
      if (!context.locals.user) throw new Error("Unauthorized");
      const userId = context.locals.user.id;

      const existing = await db.select().from(likes).where(and(eq(likes.recipeId, recipeId), eq(likes.userId, userId)));
      
      if (existing.length > 0) {
        await db.delete(likes).where(and(eq(likes.recipeId, recipeId), eq(likes.userId, userId)));
        return { liked: false };
      } else {
        await db.insert(likes).values({ id: nanoid(), recipeId, userId });
        return { liked: true };
      }
    }
  }),

  toggleBookmark: defineAction({
    accept: 'json',
    input: z.object({ recipeId: z.string() }),
    handler: async ({ recipeId }, context) => {
      if (!context.locals.user) throw new Error("Unauthorized");
      const userId = context.locals.user.id;

      const existing = await db.select().from(bookmarks).where(and(eq(bookmarks.recipeId, recipeId), eq(bookmarks.userId, userId)));
      
      if (existing.length > 0) {
        await db.delete(bookmarks).where(and(eq(bookmarks.recipeId, recipeId), eq(bookmarks.userId, userId)));
        return { bookmarked: false };
      } else {
        await db.insert(bookmarks).values({ id: nanoid(), recipeId, userId });
        return { bookmarked: true };
      }
    }
  }),

  addComment: defineAction({
    accept: 'json',
    input: z.object({ recipeId: z.string(), content: z.string().min(1).max(500) }),
    handler: async ({ recipeId, content }, context) => {
      if (!context.locals.user) throw new Error("Unauthorized");
      const [comment] = await db.insert(comments).values({
        id: nanoid(),
        recipeId,
        userId: context.locals.user.id,
        content
      }).returning();
      return comment;
    }
  })
};
